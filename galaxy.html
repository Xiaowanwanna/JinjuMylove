<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸŠçš„å£è¢‹æ»¡å¤©æ˜Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        /* å®¹å™¨å±‚çº§ç®¡ç† */
        #canvas-container { position: absolute; top: 0; left: 0; z-index: 1; width: 100vw; height: 100vh; }
        #overlay-canvas { position: absolute; top: 0; left: 0; z-index: 2; width: 100vw; height: 100vh; pointer-events: none; }
        
        /* éšè—åŸå§‹è§†é¢‘æµ */
        .input_video { display: none; }

        /* UI ç•Œé¢ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ°æŒ‰é’® */
            display: flex; flex-direction: column; justify-content: space-between;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85); color: #00ffcc;
            padding: 20px 40px; border-radius: 12px; text-align: center;
            border: 1px solid #00ffcc; box-shadow: 0 0 20px rgba(0, 255, 204, 0.2);
            pointer-events: auto;
        }

        #instructions {
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            padding: 20px; text-align: center; color: white;
            text-shadow: 0 1px 3px black;
            padding-bottom: 40px;
        }

        .guide-text { font-size: 16px; margin-bottom: 8px; color: #ddd; }
        .highlight { color: #ffaa00; font-weight: bold; }

        /* é¡¶éƒ¨æ¨¡å‹åˆ‡æ¢æ  */
        #model-selector {
            pointer-events: auto;
            display: flex; justify-content: center; gap: 20px;
            padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .btn {
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255,255,255,0.2);
            color: white; padding: 10px 25px; border-radius: 30px;
            font-size: 14px; cursor: pointer; transition: all 0.3s;
            backdrop-filter: blur(5px);
        }
        .btn.active { background: #00ffcc; color: black; border-color: #00ffcc; box-shadow: 0 0 15px rgba(0,255,204,0.4); }
        .btn:active { transform: scale(0.95); }

        /* å³ä¸Šè§’é¢„è§ˆçª—å£ */
        #camera-preview-box {
            position: absolute; top: 80px; right: 20px; 
            width: 120px; height: 160px; 
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px; overflow: hidden;
            background: #000;
            pointer-events: auto;
        }
        #camera-preview {
            width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1);
        }
    </style>
</head>
<body>

    <!-- åŠ è½½å±‚ -->
    <div id="loading">
        <h3>ç³»ç»Ÿåˆå§‹åŒ–ä¸­...</h3>
        <p>æ­£åœ¨åŠ è½½ AI æ¨¡å‹ä¸å›¾å½¢å¼•æ“</p>
        <div style="font-size:12px; color:#aaa; margin-top:10px;">è¯·æˆäºˆæ‘„åƒå¤´æƒé™</div>
    </div>

    <!-- 3D ç”»å¸ƒ -->
    <div id="canvas-container"></div>
    <!-- 2D å åŠ å±‚ (ç”»è™šçº¿æ¡†) -->
    <canvas id="overlay-canvas"></canvas>

    <!-- éšè—è§†é¢‘æº -->
    <video class="input_video" playsinline webkit-playsinline></video>

    <!-- UI å±‚ -->
    <div id="ui-layer">
        <div id="model-selector">
            <button class="btn active" onclick="switchModel('Heart', this)">â¤ï¸ æœ€çˆ±</button>
            <button class="btn" onclick="switchModel('Tangerine', this)">ğŸŠ å°æ¡”</button>
        </div>

        <!-- å°çª—é¢„è§ˆ -->
        <div id="camera-preview-box">
            <canvas id="camera-preview"></canvas>
        </div>

        <div id="instructions">
            <div class="guide-text">ğŸ‘‹ <b>å•æ‰‹æ“ä½œï¼š</b>æåˆæ‰‹æŒ‡å¹¶ç§»åŠ¨ = <span class="highlight">æ—‹è½¬æ¨¡å‹</span></div>
            <div class="guide-text">ğŸ‘ <b>åŒæ‰‹æ“ä½œï¼š</b>ä¸¤æ‰‹è·ç¦»å˜åŒ– = <span class="highlight">ç¼©æ”¾å¤§å°</span></div>
        </div>
    </div>

    <!-- åº“æ–‡ä»¶ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // ================= é…ç½®åŒº =================
        const CONFIG = {
            particleCount: 40000, // é«˜è´¨é‡ç²’å­æ•°
            particleSize: 0.12,
            smoothness: 0.1, // è¡¥é—´å¹³æ»‘åº¦
            colors: {
                heartBase: new THREE.Color(0xff0044),
                heartTip: new THREE.Color(0xff99cc),
                orangeSkin: new THREE.Color(0xff8800),
                orangeStem: new THREE.Color(0x00ff00)
            }
        };

        // ================= å…¨å±€å˜é‡ =================
        let scene, camera, renderer, particles, geometry, material;
        let targetPositions = new Float32Array(CONFIG.particleCount * 3);
        let currentPositions;
        let targetColors = new Float32Array(CONFIG.particleCount * 3);
        
        // äº¤äº’çŠ¶æ€
        let interactionState = {
            scale: 1.0,
            rotationX: 0,
            rotationY: 0,
            isPinching: false,
            lastPinchX: 0,
            lastPinchY: 0
        };

        const overlayCanvas = document.getElementById('overlay-canvas');
        const overlayCtx = overlayCanvas.getContext('2d');
        const previewCanvas = document.getElementById('camera-preview');
        const previewCtx = previewCanvas.getContext('2d');

        // ================= 1. å›¾å½¢ç”Ÿæˆ (çº¹ç†ä¸è´´å›¾) =================
        function createSoftGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.4, 'rgba(255, 255, 255, 0.5)');
            grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // ================= 2. Three.js åˆå§‹åŒ– =================
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.04);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // é«˜æ¸…å±æ”¯æŒ
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // åˆå§‹åŒ–ç²’å­
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                positions[i*3] = (Math.random()-0.5) * 10;
                positions[i*3+1] = (Math.random()-0.5) * 10;
                positions[i*3+2] = (Math.random()-0.5) * 10;
                
                colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 1;
            }

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            material = new THREE.PointsMaterial({
                size: CONFIG.particleSize,
                map: createSoftGlowTexture(),
                vertexColors: true, // å¼€å¯é¡¶ç‚¹é¢œè‰²
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // åˆå§‹æ¨¡å‹
            calculateShape('Heart');
            
            window.addEventListener('resize', onResize);
            onResize(); // åˆå§‹è°ƒç”¨ä¸€æ¬¡ç¡®ä¿å°ºå¯¸æ­£ç¡®
            animate();
        }

        // ================= 3. é«˜çº§å½¢çŠ¶ç®—æ³• =================
        function calculateShape(type) {
            const scale = 2.0;
            const positions = [];
            const colors = [];
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                let x, y, z, r, g, b;

                if (type === 'Heart') {
                    // å¿ƒå½¢æ–¹ç¨‹ (æ›´é¥±æ»¡)
                    let t = Math.random() * Math.PI * 2;
                    let u = Math.random() * Math.PI;
                    // åˆ†é…æ›´å¤šç²’å­åœ¨è¡¨é¢
                    if (Math.random() > 0.3) {
                         u = Math.asin(2 * Math.random() - 1) + Math.PI/2; // è°ƒæ•´åˆ†å¸ƒ
                    }
                    
                    x = 16 * Math.pow(Math.sin(t), 3) * Math.sin(u);
                    y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t)) * Math.sin(u);
                    z = 6 * Math.cos(u);

                    // ç¼©æ”¾
                    x *= 0.12 * scale; y *= 0.12 * scale; z *= 0.12 * scale;
                    y += 0.3; // å±…ä¸­ä¿®æ­£

                    // é¢œè‰²æ¸å˜: åº•éƒ¨æ·±çº¢ -> é¡¶éƒ¨ç²‰çº¢
                    const gradient = (y + 1.5) / 3;
                    const c = new THREE.Color().lerpColors(CONFIG.colors.heartBase, CONFIG.colors.heartTip, Math.max(0, Math.min(1, gradient)));
                    r=c.r; g=c.g; b=c.b;

                } else if (type === 'Tangerine') {
                    // æ¡”å­ (å¸¦å™ªç‚¹çš„æ‰çƒä½“)
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.acos(2 * Math.random() - 1);
                    const rad = 1.8 * scale;

                    // åŸºç¡€çƒä½“
                    x = rad * Math.sin(v) * Math.cos(u);
                    z = rad * Math.sin(v) * Math.sin(u);
                    y = rad * Math.cos(v);

                    // æ‰å¹³åŒ–
                    y *= 0.8; 

                    // è¡¨é¢çº¹ç† (Simplex Noise æ¨¡æ‹Ÿï¼Œè¿™é‡Œç”¨ç®€å•éšæœºæ‰°åŠ¨ä»£æ›¿)
                    const noise = (Math.random() - 0.5) * 0.08;
                    x += x * noise; y += y * noise; z += z * noise;

                    // é¢œè‰²åˆ¤å®šï¼šé¡¶éƒ¨æ˜¯ç»¿è’‚
                    if (y > 1.3 * scale * 0.8) {
                        // è’‚éƒ¨æ”¶ç¼©
                        x *= 0.2; z *= 0.2;
                        const c = CONFIG.colors.orangeStem;
                        r=c.r; g=c.g; b=c.b;
                    } else {
                        // æ©™è‰²çš®ï¼Œå¸¦ä¸€ç‚¹ç‚¹é»„è‰²æ–‘ç‚¹
                        const c = CONFIG.colors.orangeSkin.clone();
                        if(Math.random() > 0.9) c.offsetHSL(0.05, 0, 0.1);
                        r=c.r; g=c.g; b=c.b;
                    }
                }

                targetPositions[i*3] = x;
                targetPositions[i*3+1] = y;
                targetPositions[i*3+2] = z;
                
                targetColors[i*3] = r;
                targetColors[i*3+1] = g;
                targetColors[i*3+2] = b;
            }
        }

        window.switchModel = function(modelName, btn) {
            calculateShape(modelName);
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        };

        // ================= 4. åŠ¨ç”»ä¸æ¸²æŸ“å¾ªç¯ =================
        function animate() {
            requestAnimationFrame(animate);

            const posAttr = geometry.attributes.position;
            const colAttr = geometry.attributes.color;
            const currentPos = posAttr.array;
            const currentCol = colAttr.array;

            // å¹³æ»‘åº”ç”¨ç”¨æˆ·äº¤äº’çš„å˜æ¢
            // ç›®æ ‡æ—‹è½¬å€¼ç”± AI æ›´æ–°
            particles.rotation.x += (interactionState.rotationX - particles.rotation.x) * 0.1;
            particles.rotation.y += (interactionState.rotationY - particles.rotation.y) * 0.1;
            
            // ç¼©æ”¾å¤„ç†
            const currentScale = particles.scale.x;
            const targetScale = interactionState.scale;
            const newScale = currentScale + (targetScale - currentScale) * 0.1;
            particles.scale.set(newScale, newScale, newScale);

            // ç²’å­ä½ç½®ä¸é¢œè‰²æ’å€¼ (Morphing æ•ˆæœ)
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const idx = i * 3;
                // ä½ç½®æ’å€¼
                currentPos[idx] += (targetPositions[idx] - currentPos[idx]) * CONFIG.smoothness;
                currentPos[idx+1] += (targetPositions[idx+1] - currentPos[idx+1]) * CONFIG.smoothness;
                currentPos[idx+2] += (targetPositions[idx+2] - currentPos[idx+2]) * CONFIG.smoothness;
                
                // é¢œè‰²æ’å€¼ (ç¨å¾®æ…¢ä¸€ç‚¹ï¼Œçœ‹èµ·æ¥æ›´æŸ”å’Œ)
                currentCol[idx] += (targetColors[idx] - currentCol[idx]) * 0.05;
                currentCol[idx+1] += (targetColors[idx+1] - currentCol[idx+1]) * 0.05;
                currentCol[idx+2] += (targetColors[idx+2] - currentCol[idx+2]) * 0.05;
            }

            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // ================= 5. MediaPipe AI è§†è§‰å¤„ç† =================
        function initAI() {
            const videoElement = document.getElementsByClassName('input_video')[0];

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 2, // å¼€å¯åŒæ‰‹æ”¯æŒ
                modelComplexity: 1, // æ›´å¥½çš„ç²¾åº¦
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onAIResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640, height: 480, // ç¨å¾®æé«˜é‡‡é›†åˆ†è¾¨ç‡ä»¥è·å¾—æ›´å¥½çš„æ‰‹æŒ‡ç²¾åº¦
                facingMode: 'user'
            });

            cameraUtils.start()
                .then(() => document.getElementById('loading').style.display = 'none')
                .catch(err => {
                    document.getElementById('loading').innerHTML = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥<br>è¯·æ£€æŸ¥æƒé™";
                });
        }

        function onAIResults(results) {
            // 1. æ¸…ç©º Canvas
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // ç»˜åˆ¶é¢„è§ˆç”»é¢ (é•œåƒ)
            previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);

            const w = overlayCanvas.width;
            const h = overlayCanvas.height;
            const hands = results.multiHandLandmarks;

            if (hands && hands.length > 0) {
                
                // === ç»˜åˆ¶è™šçº¿æ¡†ä¸å…³é”®ç‚¹ ===
                overlayCtx.strokeStyle = '#00ffcc';
                overlayCtx.lineWidth = 2;
                overlayCtx.setLineDash([10, 5]); // è™šçº¿æ ·å¼

                hands.forEach(landmarks => {
                    drawBoundingBox(landmarks, w, h);
                });

                // === äº¤äº’é€»è¾‘ ===
                
                // åœºæ™¯ A: åŒæ‰‹ (ç¼©æ”¾æ¨¡å¼)
                if (hands.length === 2) {
                    const h1 = hands[0][9]; // ä¸­æŒ‡æ ¹éƒ¨ä½œä¸ºæ‰‹æŒä¸­å¿ƒ
                    const h2 = hands[1][9];
                    
                    // ç»˜åˆ¶åŒæ‰‹è¿çº¿
                    overlayCtx.beginPath();
                    overlayCtx.moveTo(h1.x * w, h1.y * h);
                    overlayCtx.lineTo(h2.x * w, h2.y * h);
                    overlayCtx.stroke();

                    // è®¡ç®—è·ç¦»
                    const dist = Math.sqrt(Math.pow(h1.x - h2.x, 2) + Math.pow(h1.y - h2.y, 2));
                    
                    // æ˜ å°„è·ç¦»åˆ°ç¼©æ”¾ (0.2 - 0.8 æ˜¯å¸¸è§æ‰‹åŠ¿èŒƒå›´)
                    // ç›®æ ‡ç¼©æ”¾ 0.5x åˆ° 2.5x
                    let scaleTarget = (dist - 0.1) * 4; 
                    if (scaleTarget < 0.5) scaleTarget = 0.5;
                    if (scaleTarget > 3.0) scaleTarget = 3.0;
                    
                    interactionState.scale = scaleTarget;
                }
                
                // åœºæ™¯ B: å•æ‰‹ (æ—‹è½¬æ¨¡å¼)
                else if (hands.length === 1) {
                    const lm = hands[0];
                    const thumb = lm[4];
                    const index = lm[8];

                    // è®¡ç®—æåˆè·ç¦»
                    const pinchDist = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));
                    const isPinching = pinchDist < 0.05; // é˜ˆå€¼

                    const palmX = lm[9].x;
                    const palmY = lm[9].y;

                    // ç»˜åˆ¶çŠ¶æ€åœ†åœˆ
                    overlayCtx.setLineDash([]);
                    overlayCtx.beginPath();
                    overlayCtx.arc(palmX * w, palmY * h, 20, 0, 2 * Math.PI);
                    overlayCtx.fillStyle = isPinching ? 'rgba(0, 255, 204, 0.5)' : 'rgba(255, 255, 255, 0.1)';
                    overlayCtx.fill();
                    overlayCtx.stroke();

                    if (isPinching) {
                        // å¦‚æœæ­£åœ¨æåˆ
                        if (!interactionState.isPinching) {
                            // åˆšå¼€å§‹æåˆï¼Œè®°å½•èµ·å§‹ç‚¹
                            interactionState.isPinching = true;
                            interactionState.lastPinchX = palmX;
                            interactionState.lastPinchY = palmY;
                        } else {
                            // æŒç»­æåˆä¸­ï¼Œè®¡ç®—ä½ç§»å·®å€¼ delta
                            const deltaX = palmX - interactionState.lastPinchX;
                            const deltaY = palmY - interactionState.lastPinchY;

                            // æ›´æ–°æ—‹è½¬ç›®æ ‡ (åè½¬ X è½´æ›´è‡ªç„¶)
                            interactionState.rotationY += deltaX * 5; 
                            interactionState.rotationX += deltaY * 5;

                            interactionState.lastPinchX = palmX;
                            interactionState.lastPinchY = palmY;
                        }
                    } else {
                        interactionState.isPinching = false;
                    }
                }

            } else {
                // æ²¡æœ‰æ‰‹æ£€æµ‹åˆ°ï¼Œæ…¢æ…¢å¤ä½ç¼©æ”¾ï¼Œä½†ä¸å¤ä½æ—‹è½¬ï¼ˆä¿æŒå§¿æ€ï¼‰
                interactionState.scale = interactionState.scale * 0.95 + 1.0 * 0.05;
                interactionState.isPinching = false;
            }
        }

        // è¾…åŠ©ï¼šç»˜åˆ¶æ‰‹éƒ¨è¾¹ç•Œè™šçº¿æ¡†
        function drawBoundingBox(landmarks, w, h) {
            let minX = 1, minY = 1, maxX = 0, maxY = 0;
            for (let lm of landmarks) {
                if (lm.x < minX) minX = lm.x;
                if (lm.x > maxX) maxX = lm.x;
                if (lm.y < minY) minY = lm.y;
                if (lm.y > maxY) maxY = lm.y;
            }
            // æ‰©å¤§ä¸€ç‚¹è¾¹è·
            const margin = 0.02;
            const x = (minX - margin) * w;
            const y = (minY - margin) * h;
            const width = (maxX - minX + margin*2) * w;
            const height = (maxY - minY + margin*2) * h;

            overlayCtx.strokeRect(x, y, width, height);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            overlayCanvas.width = window.innerWidth;
            overlayCanvas.height = window.innerHeight;
            
            previewCanvas.width = 120;
            previewCanvas.height = 160;
        }

        // å¯åŠ¨ç³»ç»Ÿ
        initThree();
        initAI();

    </script>
</body>
</html>